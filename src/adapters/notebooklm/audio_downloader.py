"""
NotebookLM Audio Downloader - Generate and download Audio Overviews (Podcasts)
"""

import asyncio
import logging
from pathlib import Path
from typing import Optional
from dataclasses import dataclass, field
from datetime import datetime

from .client import NotebookLMClient
from .notebook_manager import Notebook
from .config import Selectors

logger = logging.getLogger(__name__)


@dataclass
class AudioOverview:
    """Container for generated audio overview"""
    notebook_id: str
    notebook_title: str
    file_path: Optional[Path] = None
    duration_seconds: Optional[int] = None
    generated_at: datetime = field(default_factory=datetime.now)
    status: str = "pending"  # pending, generating, ready, failed


class AudioDownloader:
    """
    Generates and downloads Audio Overviews from NotebookLM.

    Audio Overviews are podcast-style discussions about the notebook content,
    generated by two AI hosts.

    Usage:
        async with NotebookLMClient() as client:
            downloader = AudioDownloader(client)
            audio = await downloader.generate_and_download(notebook)
    """

    def __init__(self, client: NotebookLMClient):
        self.client = client

    async def generate_and_download(
        self,
        notebook: Notebook,
        output_path: Optional[Path] = None,
        wait_for_completion: bool = True
    ) -> AudioOverview:
        """
        Generate an audio overview and download it.

        Args:
            notebook: Target notebook
            output_path: Where to save the audio file
            wait_for_completion: Whether to wait for generation to complete

        Returns:
            AudioOverview with file path and metadata
        """
        logger.info(f"Generating audio overview for notebook: {notebook.id}")

        audio = AudioOverview(
            notebook_id=notebook.id or "",
            notebook_title=notebook.title
        )

        # Navigate to notebook
        await self._ensure_notebook_open(notebook)

        # Start generation
        generation_started = await self._start_generation()
        if not generation_started:
            audio.status = "failed"
            return audio

        audio.status = "generating"

        if wait_for_completion:
            # Wait for audio to be ready
            is_ready = await self._wait_for_audio_ready()
            if not is_ready:
                audio.status = "failed"
                return audio

            audio.status = "ready"

            # Download the audio
            output_path = output_path or self._default_output_path(notebook)
            downloaded = await self._download_audio(output_path)

            if downloaded:
                audio.file_path = output_path
                audio.duration_seconds = await self._get_duration()
                logger.info(f"Audio downloaded to: {output_path}")
            else:
                audio.status = "failed"
                logger.error("Audio download failed")

        return audio

    async def _ensure_notebook_open(self, notebook: Notebook) -> None:
        """Navigate to notebook if not already open"""
        current_url = await self.client.get_current_url()
        if notebook.url and notebook.url not in current_url:
            await self.client.page.goto(notebook.url)
            await self.client.wait_for_loading()

    async def _start_generation(self) -> bool:
        """Start audio overview generation"""
        page = self.client.page

        try:
            # Click Audio Overview tab in Studio panel
            await page.click(Selectors.AUDIO_OVERVIEW_TAB, timeout=10000)
            await asyncio.sleep(1)

            # Check if audio already exists
            audio_player = await page.query_selector(Selectors.AUDIO_PLAYER)
            if audio_player:
                logger.info("Audio overview already exists")
                return True

            # Click Generate button
            generate_btn = await page.query_selector(Selectors.GENERATE_AUDIO_BUTTON)
            if generate_btn:
                await generate_btn.click()
                logger.info("Audio generation started")
                return True

            # Try alternative button text
            alt_buttons = [
                'button:has-text("Generate audio")',
                'button:has-text("Create audio")',
                'button:has-text("Generate")',
            ]

            for selector in alt_buttons:
                btn = await page.query_selector(selector)
                if btn:
                    await btn.click()
                    logger.info("Audio generation started (alt button)")
                    return True

            logger.error("Could not find generate button")
            return False

        except Exception as e:
            logger.error(f"Failed to start generation: {e}")
            return False

    async def _wait_for_audio_ready(self) -> bool:
        """Wait for audio generation to complete"""
        page = self.client.page
        timeout = self.client.config.audio_generation_timeout
        poll_interval = 5000  # 5 seconds

        logger.info(f"Waiting for audio generation (timeout: {timeout/1000}s)...")

        elapsed = 0
        while elapsed < timeout:
            try:
                # Check for audio player
                audio_player = await page.query_selector(Selectors.AUDIO_PLAYER)
                if audio_player:
                    # Check if it has a source
                    src = await audio_player.get_attribute("src")
                    if src:
                        logger.info("Audio is ready")
                        return True

                # Check for download button (alternative indicator)
                download_btn = await page.query_selector(Selectors.DOWNLOAD_AUDIO_BUTTON)
                if download_btn and await download_btn.is_visible():
                    logger.info("Audio is ready (download button visible)")
                    return True

                # Check for error
                error = await self.client.check_for_error()
                if error:
                    logger.error(f"Audio generation error: {error}")
                    return False

                # Check for "generating" status text
                status_text = await page.query_selector('[class*="status"], [class*="progress"]')
                if status_text:
                    text = await status_text.text_content()
                    if text:
                        logger.debug(f"Generation status: {text}")

            except Exception as e:
                logger.debug(f"Wait check error: {e}")

            await asyncio.sleep(poll_interval / 1000)
            elapsed += poll_interval

        logger.error("Audio generation timed out")
        return False

    async def _download_audio(self, output_path: Path) -> bool:
        """Download the generated audio file"""
        page = self.client.page

        try:
            # Ensure output directory exists
            output_path.parent.mkdir(parents=True, exist_ok=True)

            # Method 1: Use download button
            download_btn = await page.query_selector(Selectors.DOWNLOAD_AUDIO_BUTTON)
            if download_btn:
                # Set up download handler
                async with page.expect_download() as download_info:
                    await download_btn.click()

                download = await download_info.value
                await download.save_as(str(output_path))
                return True

            # Method 2: Get audio source URL and download directly
            audio_player = await page.query_selector(Selectors.AUDIO_PLAYER)
            if audio_player:
                src = await audio_player.get_attribute("src")
                if src:
                    # Download via fetch
                    response = await page.request.get(src)
                    if response.ok:
                        content = await response.body()
                        output_path.write_bytes(content)
                        return True

            # Method 3: Try finding any download link
            download_links = await page.query_selector_all('a[download], a[href*=".mp3"], a[href*="audio"]')
            for link in download_links:
                href = await link.get_attribute("href")
                if href:
                    async with page.expect_download() as download_info:
                        await link.click()
                    download = await download_info.value
                    await download.save_as(str(output_path))
                    return True

            logger.error("Could not find download method")
            return False

        except Exception as e:
            logger.error(f"Download failed: {e}")
            return False

    async def _get_duration(self) -> Optional[int]:
        """Get audio duration in seconds"""
        page = self.client.page

        try:
            audio_player = await page.query_selector(Selectors.AUDIO_PLAYER)
            if audio_player:
                duration = await page.evaluate(
                    "(audio) => audio.duration",
                    audio_player
                )
                if duration and not str(duration) == "NaN":
                    return int(duration)
        except Exception:
            pass

        return None

    def _default_output_path(self, notebook: Notebook) -> Path:
        """Generate default output path for audio file"""
        safe_title = "".join(c if c.isalnum() or c in " -_" else "_" for c in notebook.title)
        safe_title = safe_title[:50]  # Limit length
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{safe_title}_{timestamp}.mp3"
        return self.client.config.audio_dir / filename

    async def check_audio_exists(self, notebook: Notebook) -> bool:
        """Check if audio overview already exists for notebook"""
        await self._ensure_notebook_open(notebook)

        page = self.client.page

        try:
            # Click Audio Overview tab
            await page.click(Selectors.AUDIO_OVERVIEW_TAB, timeout=5000)
            await asyncio.sleep(1)

            # Check for audio player
            audio_player = await page.query_selector(Selectors.AUDIO_PLAYER)
            if audio_player:
                src = await audio_player.get_attribute("src")
                return bool(src)

            # Check for download button
            download_btn = await page.query_selector(Selectors.DOWNLOAD_AUDIO_BUTTON)
            return download_btn is not None and await download_btn.is_visible()

        except Exception:
            return False

    async def delete_audio(self, notebook: Notebook) -> bool:
        """Delete existing audio overview (to regenerate)"""
        await self._ensure_notebook_open(notebook)

        page = self.client.page

        try:
            # Click Audio Overview tab
            await page.click(Selectors.AUDIO_OVERVIEW_TAB, timeout=5000)

            # Look for delete button
            delete_selectors = [
                'button[aria-label*="Delete"]',
                'button:has-text("Delete")',
                'button:has-text("Remove")',
            ]

            for selector in delete_selectors:
                btn = await page.query_selector(selector)
                if btn:
                    await btn.click()
                    # Confirm if needed
                    try:
                        await page.click('button:has-text("Delete")', timeout=3000)
                    except Exception:
                        pass
                    logger.info("Audio deleted")
                    return True

            return False

        except Exception as e:
            logger.error(f"Delete audio failed: {e}")
            return False
